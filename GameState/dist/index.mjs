let e;const t=new Uint8Array(16);function s(){if(!e&&(e="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!e))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return e(t)}const r=[];for(let e=0;e<256;++e)r.push((e+256).toString(16).slice(1));var o,n={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function c(e,t,o){if(n.randomUUID&&!t&&!e)return n.randomUUID();const c=(e=e||{}).random||(e.rng||s)();if(c[6]=15&c[6]|64,c[8]=63&c[8]|128,t){o=o||0;for(let e=0;e<16;++e)t[o+e]=c[e];return t}return function(e,t=0){return(r[e[t+0]]+r[e[t+1]]+r[e[t+2]]+r[e[t+3]]+"-"+r[e[t+4]]+r[e[t+5]]+"-"+r[e[t+6]]+r[e[t+7]]+"-"+r[e[t+8]]+r[e[t+9]]+"-"+r[e[t+10]]+r[e[t+11]]+r[e[t+12]]+r[e[t+13]]+r[e[t+14]]+r[e[t+15]]).toLowerCase()}(c)}!function(e){e.Rock="rock",e.Paper="paper",e.Scissors="scissors"}(o||(o={}));class i{id;players;rounds;currentRound;storage;dolocation;constructor(e){this.id=e.id.toString(),this.players=new Map,this.rounds=new Array,this.currentRound=0,this.storage=e.storage,this.dolocation="",this.scheduleNextAlarm(this.storage),this.getDurableObjectLocation()}async fetch(e){const{headers:t,cf:s}=e;if("websocket"===t.get("upgrade")&&void 0!==s){if(this.players.size>1)return new Response("Game is FULL!",{status:403});let e=new WebSocketPair;const[t,r]=Object.values(e),o=await this.handleWebSocketSession(r,s);return new Response(JSON.stringify({id:o?.id}),{status:101,webSocket:t})}return new Response(this.id)}resolveRound(){const[e,t]=this.players,s=this.rounds[this.currentRound];return s.choices.get(e[0])===o.Rock&&s.choices.get(t[0])===o.Scissors||s.choices.get(e[0])===o.Paper&&s.choices.get(t[0])===o.Rock||s.choices.get(e[0])===o.Scissors&&s.choices.get(t[0])===o.Paper?s.winner=e[0]:s.winner=t[0],this.rounds[this.currentRound]=s,this.currentRound++,s}async handleWebSocketSession(e,t){e.accept();const s=c();this.players.set(s,{id:s,websocket:e,wins:0}),e.addEventListener("message",(async t=>{try{let e=JSON.parse(t.data.toString());this.rounds[this.currentRound].choices.set(s,e.choice);const r={type:"choice",data:{playerId:s}};return this.broadcast(JSON.stringify(r))}catch(t){t instanceof Error?e.send(JSON.stringify({error:t.stack})):e.send("something went wrong")}}));let r=()=>{console.log("player",s)};return e.addEventListener("close",r),e.addEventListener("error",r),this.players.get(s)}broadcast(e){this.players.forEach((t=>{try{t.websocket.send(e)}catch(e){console.log(`broadcast error: ${t}`)}}))}async getDurableObjectLocation(){const e=await fetch("https://workers.cloudflare.com/cf.json"),t=await e.json();this.dolocation=`${t.city} (${t.country})`}scheduleNextAlarm(e){try{const t=Date.now()+1e4;e.setAlarm(t)}catch{console.log("Durable Objects Alarms not supported in Miniflare (--local mode) yet.")}}alarm(){if(2==this.rounds[this.currentRound].choices.size){const e={type:"round",data:this.resolveRound()};this.broadcast(JSON.stringify([e]))}else{const e={type:"healthcheck"};this.broadcast(JSON.stringify([e]))}this.players.size&&this.scheduleNextAlarm(this.storage)}}var a={fetch:()=>new Response("This Worker creates the GameState Durable Object.")};export{i as GameState,a as default};
//# sourceMappingURL=index.mjs.map
